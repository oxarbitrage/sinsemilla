-------------------------------- MODULE Utils -------------------------------
LOCAL INSTANCE Sequences
LOCAL INSTANCE Naturals

\* A function that returns the ASCII value of an "allowed" character
Ord(c) ==
    CASE
        c = " " -> 32
        [] c = "." -> 46
        [] c = "0" -> 48
        [] c = "1" -> 49
        [] c = "2" -> 50
        [] c = "3" -> 51
        [] c = "4" -> 52
        [] c = "5" -> 53
        [] c = "6" -> 54
        [] c = "7" -> 55
        [] c = "8" -> 56
        [] c = "9" -> 57
        [] c = "a" -> 97
        [] c = "b" -> 98
        [] c = "c" -> 99
        [] c = "d" -> 100
        [] c = "e" -> 101
        [] c = "f" -> 102
        [] c = "g" -> 103
        [] c = "h" -> 104
        [] c = "i" -> 105
        [] c = "j" -> 106
        [] c = "k" -> 107
        [] c = "l" -> 108
        [] c = "m" -> 109
        [] c = "n" -> 110
        [] c = "o" -> 111
        [] c = "p" -> 112
        [] c = "q" -> 113
        [] c = "r" -> 114
        [] c = "s" -> 115
        [] c = "t" -> 116
        [] c = "u" -> 117
        [] c = "v" -> 118
        [] c = "w" -> 119
        [] c = "x" -> 120
        [] c = "y" -> 121
        [] c = "z" -> 122
        [] OTHER -> 0  \* Default to 0 for unspecified characters

\* Inverse of Ord function, using 'b' as the parameter
Chr(b) ==
    CASE
        b = 32 -> " "
        [] b = 46 -> "."
        [] b = 48 -> "0"
        [] b = 49 -> "1"
        [] b = 50 -> "2"
        [] b = 51 -> "3"
        [] b = 52 -> "4"
        [] b = 53 -> "5"
        [] b = 54 -> "6"
        [] b = 55 -> "7"
        [] b = 56 -> "8"
        [] b = 57 -> "9"
        [] b = 97 -> "a"
        [] b = 98 -> "b"
        [] b = 99 -> "c"
        [] b = 100 -> "d"
        [] b = 101 -> "e"
        [] b = 102 -> "f"
        [] b = 103 -> "g"
        [] b = 104 -> "h"
        [] b = 105 -> "i"
        [] b = 106 -> "j"
        [] b = 107 -> "k"
        [] b = 108 -> "l"
        [] b = 109 -> "m"
        [] b = 110 -> "n"
        [] b = 111 -> "o"
        [] b = 112 -> "p"
        [] b = 113 -> "q"
        [] b = 114 -> "r"
        [] b = 115 -> "s"
        [] b = 116 -> "t"
        [] b = 117 -> "u"
        [] b = 118 -> "v"
        [] b = 119 -> "w"
        [] b = 120 -> "x"
        [] b = 121 -> "y"
        [] b = 122 -> "z"
        [] OTHER -> "@"  \* Default to "@" for unspecified ASCII values
    
ByteToBitSequence(b) ==
    CASE
        b = 32 -> <<0, 0, 1, 0, 0, 0, 0, 0>>  \* Space
        [] b = 46 -> <<0, 0, 1, 0, 1, 1, 1, 0>>  \* Dot '.'
        [] b = 48 -> <<0, 0, 1, 1, 0, 0, 0, 0>>  \* '0'
        [] b = 49 -> <<0, 0, 1, 1, 0, 0, 0, 1>>  \* '1'
        [] b = 50 -> <<0, 0, 1, 1, 0, 0, 1, 0>>  \* '2'
        [] b = 51 -> <<0, 0, 1, 1, 0, 0, 1, 1>>  \* '3'
        [] b = 52 -> <<0, 0, 1, 1, 0, 1, 0, 0>>  \* '4'
        [] b = 53 -> <<0, 0, 1, 1, 0, 1, 0, 1>>  \* '5'
        [] b = 54 -> <<0, 0, 1, 1, 0, 1, 1, 0>>  \* '6'
        [] b = 55 -> <<0, 0, 1, 1, 0, 1, 1, 1>>  \* '7'
        [] b = 56 -> <<0, 0, 1, 1, 1, 0, 0, 0>>  \* '8'
        [] b = 57 -> <<0, 0, 1, 1, 1, 0, 0, 1>>  \* '9'
        [] b = 97 -> <<0, 1, 1, 0, 0, 0, 0, 1>>  \* 'a'
        [] b = 98 -> <<0, 1, 1, 0, 0, 0, 1, 0>>  \* 'b'
        [] b = 99 -> <<0, 1, 1, 0, 0, 0, 1, 1>>  \* 'c'
        [] b = 100 -> <<0, 1, 1, 0, 0, 1, 0, 0>>  \* 'd'
        [] b = 101 -> <<0, 1, 1, 0, 0, 1, 0, 1>>  \* 'e'
        [] b = 102 -> <<0, 1, 1, 0, 0, 1, 1, 0>>  \* 'f'
        [] b = 103 -> <<0, 1, 1, 0, 0, 1, 1, 1>>  \* 'g'
        [] b = 104 -> <<0, 1, 1, 0, 1, 0, 0, 0>>  \* 'h'
        [] b = 105 -> <<0, 1, 1, 0, 1, 0, 0, 1>>  \* 'i'
        [] b = 106 -> <<0, 1, 1, 0, 1, 0, 1, 0>>  \* 'j'
        [] b = 107 -> <<0, 1, 1, 0, 1, 0, 1, 1>>  \* 'k'
        [] b = 108 -> <<0, 1, 1, 0, 1, 1, 0, 0>>  \* 'l'
        [] b = 109 -> <<0, 1, 1, 0, 1, 1, 0, 1>>  \* 'm'
        [] b = 110 -> <<0, 1, 1, 0, 1, 1, 1, 0>>  \* 'n'
        [] b = 111 -> <<0, 1, 1, 0, 1, 1, 1, 1>>  \* 'o'
        [] b = 112 -> <<0, 1, 1, 1, 0, 0, 0, 0>>  \* 'p'
        [] b = 113 -> <<0, 1, 1, 1, 0, 0, 0, 1>>  \* 'q'
        [] b = 114 -> <<0, 1, 1, 1, 0, 0, 1, 0>>  \* 'r'
        [] b = 115 -> <<0, 1, 1, 1, 0, 0, 1, 1>>  \* 's'
        [] b = 116 -> <<0, 1, 1, 1, 0, 1, 0, 0>>  \* 't'
        [] b = 117 -> <<0, 1, 1, 1, 0, 1, 0, 1>>  \* 'u'
        [] b = 118 -> <<0, 1, 1, 1, 0, 1, 1, 0>>  \* 'v'
        [] b = 119 -> <<0, 1, 1, 1, 0, 1, 1, 1>>  \* 'w'
        [] b = 120 -> <<0, 1, 1, 1, 1, 0, 0, 0>>  \* 'x'
        [] b = 121 -> <<0, 1, 1, 1, 1, 0, 0, 1>>  \* 'y'
        [] b = 122 -> <<0, 1, 1, 1, 1, 0, 1, 0>>  \* 'z'
        [] OTHER -> <<0, 0, 0, 0, 0, 0, 0, 0>>  \* Default to 0 for unspecified bytes

\* A flatten operator copied from https://github.com/tlaplus/CommunityModules/blob/master/modules/SequencesExt.tla
FlattenSeq(seqs) ==
(**************************************************************************)
(* A sequence of all elements from all sequences in the sequence  seqs  . *)
(*                                                                        *)
(* Examples:                                                              *)
(*                                                                        *)
(*  FlattenSeq(<< <<1,2>>, <<1>> >>) = << 1, 2, 1 >>                      *)
(*  FlattenSeq(<< <<"a">>, <<"b">> >>) = <<"a", "b">>                     *)
(*  FlattenSeq(<< "a", "b" >>) = "ab"                                     *)
(**************************************************************************)
IF Len(seqs) = 0 THEN seqs ELSE
    \* Not via  FoldSeq(\o, <<>>, seqs)  here to support strings with TLC.
    LET flatten[i \in 1..Len(seqs)] ==
        IF i = 1 THEN seqs[i] ELSE flatten[i-1] \o seqs[i]
    IN flatten[Len(seqs)]

=============================================================================
